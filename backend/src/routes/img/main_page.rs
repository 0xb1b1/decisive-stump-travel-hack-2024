use rocket::{
    http::Status,
    response::status,
    serde::json::Json, // form::Form,
};
// use rocket::http::{
//     ContentType,
//     MediaType
// };
// use rsmq_async::{PooledRsmq, RsmqConnection};
// use tokio::io::AsyncReadExt;
use log;
use s3::Bucket;

// use crate::enums::rsmq::RsmqDsQueue;
// use crate::enums::worker::TaskType;
use ds_travel_hack_2024::models::http::main_page::{GalleryResponse, RedisGalleryStore};
// use crate::utils::s3::images::get_img;
use ds_travel_hack_2024::utils;

pub fn routes() -> Vec<rocket::Route> {
    routes![get_gallery,]
}

#[get("/gallery?<token>&<amount>")]
async fn get_gallery(
    token: Option<String>,
    amount: Option<u32>,
    _bucket: &rocket::State<Bucket>, // TODO: Remove this after moving parser to worker?
    redis_pool: &rocket::State<bb8::Pool<bb8_redis::RedisConnectionManager>>,
) -> status::Custom<Json<GalleryResponse>> {
    // Takes optional token and amount. Token is used for pagination (generated by the backend)
    // and saved as key in Redis. Amount is the number of images to return.
    // If no token is supplied, a new one will be returned, otherwise the existing token will be used.
    // If no amount is supplied, a default amount will be used.
    // If token is supplied and found in Redis, the gallery data stored in Redis will be deserialized
    // and returned, with all returned images popped from the Redis list.
    log::debug!(
        "Gallery request received ({:?}): amount={:?}",
        token,
        amount
    );

    let mut cached_gallery: Option<RedisGalleryStore>;

    if let Some(ref t) = token {
        // Get images:collections:main:full:token from redis
        match utils::redis::galleries::get_gallery_by_token(&t, &redis_pool).await {
            Some(gallery) => {
                cached_gallery = Some(gallery);
            }
            None => {
                log::debug!("No cached gallery found for token: {}", t);
                cached_gallery = None;
            }
        }
    } else {
        cached_gallery = None;
    }

    // Ensure that final_amount is not bigger than the vector stored in Redis
    let mut final_amount: u32 = amount.unwrap_or(50);
    if let Some(ref gallery) = cached_gallery {
        if final_amount > gallery.images.len() as u32 {
            final_amount = gallery.images.len() as u32;
        }
    }

    let final_token = match token {
        Some(t) => t,
        None => utils::rng::tokens::generate_token(),
    };

    let mut return_images: GalleryResponse = GalleryResponse {
        images: vec![],
        token: final_token.clone(),
        error: None,
    };

    let to_redis_gallery: RedisGalleryStore;

    // If cached_gallery is not None, get last <amount> items from the beginning of the images Vector.
    if let Some(ref mut gallery) = cached_gallery {
        for _ in 0..final_amount {
            if let Some(image) = gallery.images.pop() {
                return_images.images.push(image);
            } else {
                break;
            }
        }
        to_redis_gallery = gallery.clone();
    } else {
        // Get images:collections:main:full from redis
        let mut derived_gallery: RedisGalleryStore =
            match utils::redis::galleries::get_main_gallery(&redis_pool).await {
                Ok(gallery) => gallery,
                Err(e) => {
                    log::error!("Failed to get gallery from Redis: {}", e);
                    return_images.error = Some("Failed to get gallery from Redis.".to_string());
                    return status::Custom(Status::InternalServerError, Json(return_images));
                }
            };

        // Ensure that final_amount is not bigger than the vector stored in Redis
        if final_amount > derived_gallery.images.len() as u32 {
            final_amount = derived_gallery.images.len() as u32;
        }

        for _ in 0..final_amount {
            if let Some(image) = derived_gallery.images.pop() {
                return_images.images.push(image);
            } else {
                break;
            }
        }
        to_redis_gallery = derived_gallery.clone();
    }

    match utils::redis::galleries::set_gallery_by_token(
        &final_token,
        &to_redis_gallery,
        &redis_pool,
    )
    .await
    {
        Ok(_) => {
            log::debug!(
                "Gallery stored in Redis: images:collections:main:full:by_token:{}",
                final_token
            );
        }
        Err(e) => {
            log::error!("Failed to store gallery in Redis: {}", e);
            return_images.error = Some("Failed to store gallery in Redis.".to_string());
            return status::Custom(Status::InternalServerError, Json(return_images));
        }
    }
    status::Custom(Status::Ok, Json(return_images))
}
